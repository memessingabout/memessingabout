#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import json
import math
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from pathlib import Path
from datetime import datetime
import gpxpy
import folium
from folium.plugins import AntPath, MiniMap
import webbrowser
import pandas as pd

# ----------------------------------------------------------------------
# CONFIG
# ----------------------------------------------------------------------
SETTINGS_FILE = Path("settings.json")
MAPS_DIR = Path("maps")
MAPS_DIR.mkdir(exist_ok=True)

# Default offline MBTiles (place in same folder)
OFFLINE_TILES = Path("switzerland.mbtiles")  # Change to your file

# Load settings
def load_settings():
    if SETTINGS_FILE.exists():
        try:
            with SETTINGS_FILE.open('r', encoding='utf-8') as f:
                return json.load(f)
        except:
            pass
    return {"last_folder": "", "dark_mode": False, "show_legend": True}

def save_settings(data):
    with SETTINGS_FILE.open('w', encoding='utf-8') as f:
        json.dump(data, f, indent=2)

settings = load_settings()

# ----------------------------------------------------------------------
# HELPER: Haversine
# ----------------------------------------------------------------------
def haversine(p1, p2):
    lat1, lon1 = math.radians(p1[0]), math.radians(p1[1])
    lat2, lon2 = math.radians(p2[0]), math.radians(p2[1])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
    return 6371000 * 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

# ----------------------------------------------------------------------
# SPEED TO COLOR
# ----------------------------------------------------------------------
def speed_to_color(speed_mps):
    if speed_mps is None:
        return "#888888"
    kmh = speed_mps * 3.6
    if kmh < 5:   return "#00ff00"
    if kmh < 15:  return "#88ff00"
    if kmh < 30:  return "#ffff00"
    if kmh < 50:  return "#ff8800"
    return "#ff0000"

# ----------------------------------------------------------------------
# ENRICH TRACK
# ----------------------------------------------------------------------
def enrich_track(track):
    points = []
    prev = None
    for seg in track.segments:
        for p in seg.points:
            cur = (p.latitude, p.longitude)
            speed = None
            duration = None
            if prev and p.time and prev["time"]:
                dist = haversine(prev["coord"], cur)
                dt = (p.time - prev["time"]).total_seconds()
                if dt > 0:
                    speed = dist / dt
                    duration = dt
            points.append({
                "coord": cur,
                "time": p.time,
                "elev": p.elevation,
                "speed": speed,
                "duration": duration
            })
            prev = points[-1]
    return points

# ----------------------------------------------------------------------
# CREATE MAP
# ----------------------------------------------------------------------
def create_map(gpx, date_str: str, output_path: Path, dark_mode: bool, show_legend: bool):
    all_coords = []
    track_segments = []

    for track in gpx.tracks:
        enriched = enrich_track(track)
        if len(enriched) < 2:
            continue
        coords = [p["coord"] for p in enriched]
        all_coords.extend(coords)
        track_segments.append((coords, enriched))

    route_coords = [(p.latitude, p.longitude) for r in gpx.routes for p in r.points]
    if route_coords:
        all_coords.extend(route_coords)

    if not all_coords:
        return False, "No track data"

    lats, lons = zip(*all_coords)
    center = [sum(lats)/len(lats), sum(lons)/len(lons)]

    # --- Folium Map ---
    tile_layer = 'cartodbpositron' if not dark_mode else 'cartodbdark_matter'
    m = folium.Map(location=center, zoom_start=13, tiles=tile_layer)

    # --- Offline MBTiles (if exists) ---
    if OFFLINE_TILES.exists():
        try:
            folium.TileLayer(
                tiles=f'file://{OFFLINE_TILES.resolve()}',
                attr='Offline MBTiles',
                name='Offline',
                overlay=False
            ).add_to(m)
        except:
            pass

    m.fit_bounds([[min(lats), min(lons)], [max(lats), max(lons)]])

    # --- Animated & Colored Route ---
    for coords, enriched in track_segments:
        # Full path animation
        AntPath(
            locations=coords,
            color="#ff00ff",
            weight=4,
            opacity=0.8,
            delay=1000,
            dash_array=[10, 20],
            pulse_color="#00ffff"
        ).add_to(m)

        # Speed-colored segments
        for i in range(len(coords) - 1):
            seg = [coords[i], coords[i+1]]
            speed = enriched[i+1]["speed"]
            folium.PolyLine(seg, color=speed_to_color(speed), weight=3, opacity=0.9).add_to(m)

    # --- Start / Finish ---
    if track_segments:
        first = track_segments[0][1][0]
        last = track_segments[-1][1][-1]

        total_dist = sum(
            haversine(coords[i], coords[i+1])
            for seg_coords, _ in track_segments
            for i in range(len(seg_coords)-1)
        ) / 1000

        folium.Marker(
            first["coord"],
            popup=folium.Popup(f"""
                <b>START</b><br>
                Time: {first['time'].strftime('%H:%M:%S') if first['time'] else '—'}<br>
                Elev: {first['elev'] or '—'} m
            """, max_width=200),
            icon=folium.Icon(color="green", icon="play", prefix='fa')
        ).add_to(m)

        folium.Marker(
            last["coord"],
            popup=folium.Popup(f"""
                <b>FINISH</b><br>
                Time: {last['time'].strftime('%H:%M:%S') if last['time'] else '—'}<br>
                Elev: {last['elev'] or '—'} m<br>
                Total: {total_dist:.2f} km
            """, max_width=200),
            icon=folium.Icon(color="darkred", icon="stop", prefix='fa')
        ).add_to(m)

    # --- Waypoints (Stops) with duration, time, elev ---
    for wp in gpx.waypoints:
        time_str = wp.time.strftime('%H:%M:%S') if wp.time else '—'
        elev_str = f"{wp.elevation:.1f} m" if wp.elevation else '—'
        duration = "—"
        if wp.extensions:
            try:
                duration = wp.extensions.get("duration", "—")
            except:
                pass

        popup_html = f"""
            <div style="font-family: Arial; font-size: 13px;">
                <b>{wp.name or 'Stop'}</b><br>
                Time: {time_str}<br>
                Elevation: {elev_str}<br>
                Duration: {duration}
            </div>
        """
        folium.CircleMarker(
            [wp.latitude, wp.longitude],
            radius=7,
            color="purple",
            fill=True,
            popup=folium.Popup(popup_html, max_width=250)
        ).add_to(m)

    # --- MiniMap ---
    MiniMap().add_to(m)

    # --- Speed Legend (toggleable) ---
    legend_html = '''
    <div id="legend-container" style="position: fixed; bottom: 60px; left: 20px; z-index: 1000;">
        <button id="legend-toggle" onclick="toggleLegend()" 
                style="background:#333; color:white; border:none; padding:8px 12px; 
                       border-radius:6px; cursor:pointer; font-size:12px;">
            Show Legend
        </button>
        <div id="speed-legend" style="display: none; margin-top:5px; background:white; 
             padding:12px; border:2px solid #555; border-radius:8px; font-family:Arial; 
             font-size:13px; box-shadow:0 0 10px rgba(0,0,0,0.3);">
            <b>Speed Legend</b><br>
            <div><i style="background:#00ff00;width:12px;height:12px;display:inline-block;border-radius:50%;"></i> &lt;5 km/h</div>
            <div><i style="background:#88ff00;"></i> 5–15 km/h</div>
            <div><i style="background:#ffff00;"></i> 15–30 km/h</div>
            <div><i style="background:#ff8800;"></i> 30–50 km/h</div>
            <div><i style="background:#ff0000;"></i> &gt;50 km/h</div>
            <hr style="margin:8px 0;">
            <small>Click button to hide</small>
        </div>
    </div>
    <script>
    function toggleLegend() {
        var legend = document.getElementById('speed-legend');
        var btn = document.getElementById('legend-toggle');
        if (legend.style.display === 'none') {
            legend.style.display = 'block';
            btn.innerText = 'Hide Legend';
        } else {
            legend.style.display = 'none';
            btn.innerText = 'Show Legend';
        }
    }
    ''' + ('''
    toggleLegend();  // Auto-show on load
    ''' if show_legend else '') + '''
    </script>
    '''
    m.get_root().html.add_child(folium.Element(legend_html))

    # --- Dark Mode CSS ---
    if dark_mode:
        dark_css = """
        <style>
        .folium-map { filter: invert(1) hue-rotate(180deg); }
        img { filter: invert(1) hue-rotate(180deg); }
        </style>
        """
        m.get_root().html.add_child(folium.Element(dark_css))

    # --- Signature ---
    m.get_root().html.add_child(folium.Element("<!-- Living on Love -->"))

    # --- Save ---
    if output_path.exists():
        if not messagebox.askyesno("Overwrite?", f"File exists:\n{output_path.name}\nOverwrite?"):
            return False, "Cancelled"

    m.save(str(output_path))
    return True, str(output_path)

# ----------------------------------------------------------------------
# TKINTER GUI
# ----------------------------------------------------------------------
class GPXMapperGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("GPX Route Animator")
        self.root.geometry("520x380")
        self.root.resizable(False, False)

        # Variables
        self.folder_var = tk.StringVar(value=settings.get("last_folder", ""))
        self.dark_var = tk.BooleanVar(value=settings.get("dark_mode", False))
        self.legend_var = tk.BooleanVar(value=settings.get("show_legend", True))

        self.setup_ui()

    def setup_ui(self):
        pad = {'padx': 10, 'pady': 5}

        # Title
        tk.Label(self.root, text="GPX Route Animator", font=("Arial", 16, "bold")).pack(pady=10)

        # Folder
        frame1 = ttk.Frame(self.root)
        frame1.pack(fill='x', **pad)
        tk.Label(frame1, text="GPX Folder:").pack(side='left')
        tk.Entry(frame1, textvariable=self.folder_var, width=40).pack(side='left', padx=5, expand=True, fill='x')
        ttk.Button(frame1, text="Browse", command=self.browse_folder).pack(side='right')

        # File list
        self.listbox = tk.Listbox(self.root, height=8)
        self.listbox.pack(fill='both', expand=True, **pad)
        self.listbox.bind('<<ListboxSelect>>', self.on_select)

        # Options
        frame2 = ttk.Frame(self.root)
        frame2.pack(fill='x', **pad)
        ttk.Checkbutton(frame2, text="Dark Mode", variable=self.dark_var).pack(side='left')
        ttk.Checkbutton(frame2, text="Show Legend", variable=self.legend_var).pack(side='left', padx=20)

        # Buttons
        frame3 = ttk.Frame(self.root)
        frame3.pack(fill='x', **pad)
        ttk.Button(frame3, text="Refresh Files", command=self.load_files).pack(side='left', padx=5)
        ttk.Button(frame3, text="Generate Map", command=self.generate_map).pack(side='right', padx=5)

        # Status
        self.status = tk.Label(self.root, text="Ready", anchor='w', fg="gray")
        self.status.pack(fill='x', **pad)

        # Load initial
        self.load_files()

    def browse_folder(self):
        folder = filedialog.askdirectory(initialdir=self.folder_var.get())
        if folder:
            self.folder_var.set(folder)
            self.load_files()

    def load_files(self):
        folder = Path(self.folder_var.get())
        if not folder.is_dir():
            self.listbox.delete(0, tk.END)
            self.status.config(text="Invalid folder", fg="red")
            return

        settings["last_folder"] = str(folder.resolve())
        save_settings(settings)

        self.listbox.delete(0, tk.END)
        files = [f for f in folder.iterdir() if f.suffix.lower() == '.gpx']
        dates = []
        for f in files:
            try:
                d = f.name.split('_', 1)[0]
                datetime.strptime(d, '%Y-%m-%d')
                dates.append((d, f))
            except:
                continue
        dates.sort()
        for d, f in dates:
            self.listbox.insert(tk.END, f"{d} → {f.name}")
        self.status.config(text=f"{len(dates)} dated files", fg="green")

    def on_select(self, event):
        pass

    def generate_map(self):
        sel = self.listbox.curselection()
        if not sel:
            messagebox.showwarning("No Selection", "Please select a GPX file.")
            return

        item = self.listbox.get(sel[0])
        date_str = item.split(' → ')[0]
        gpx_path = Path(self.folder_var.get()) / item.split(' → ')[1]

        try:
            with gpx_path.open('r', encoding='utf-8') as f:
                gpx = gpxpy.parse(f)
        except Exception as e:
            messagebox.showerror("Parse Error", f"Failed to parse GPX:\n{e}")
            return

        html_name = f"{date_str}_route.html"
        output_path = MAPS_DIR / html_name

        self.status.config(text="Generating map...", fg="blue")
        self.root.update()

        success, msg = create_map(
            gpx=gpx,
            date_str=date_str,
            output_path=output_path,
            dark_mode=self.dark_var.get(),
            show_legend=self.legend_var.get()
        )

        if success:
            settings["dark_mode"] = self.dark_var.get()
            settings["show_legend"] = self.legend_var.get()
            save_settings(settings)
            self.status.config(text=f"Saved: {html_name}", fg="green")
            webbrowser.open(str(output_path.resolve()))
        else:
            self.status.config(text=msg, fg="red")

# ----------------------------------------------------------------------
# MAIN
# ----------------------------------------------------------------------
if __name__ == '__main__':
    root = tk.Tk()
    app = GPXMapperGUI(root)
    root.mainloop()