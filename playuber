// scrape-uber-earnings.ts
import { chromium, BrowserContext, Page } from 'playwright';
import * as fs from 'fs';
import * as path from 'path';

// ==================== CONFIG ====================
const BRAVE_PROFILE_PATH = 'C:\\Users\\YourName\\AppData\\Local\\BraveSoftware\\Brave-Browser\\User Data'; // CHANGE THIS
const OUTPUT_FILE = 'uber_earnings_full_history.csv';
const LOG_FILE = 'scraper.log';
const MAX_WEEKS_BACK = 520; // ~10 years max
const DELAY_BETWEEN_DETAILS = 800; // ms

// ==================== LOGGING ====================
const log = (msg: string, level: 'INFO' | 'WARN' | 'ERROR' = 'INFO') => {
  const timestamp = new Date().toISOString();
  const line = `[${timestamp}] [${level}] ${msg}\n`;
  console.log(line.trim());
  fs.appendFileSync(LOG_FILE, line);
};

// ==================== CSV HELPERS ====================
let csvHeaders: string[] = [];
let csvRows: string[][] = [];

const initCSV = () => {
  csvHeaders = [
    'Type', 'Date', 'Time', 'TripID', 'ActivityFeedUUID', 'Event', 'Earnings_KSH',
    'Duration', 'Distance_KM', 'Fare', 'ServiceFee', 'Taxes', 'YourEarnings',
    'Payouts', 'TripBalance', 'Quest_Trips_Completed', 'Quest_Bonus', 'Validation'
  ];
  csvRows = [csvHeaders];
};

const addRow = (data: any) => {
  const row = csvHeaders.map(h => String(data[h] ?? '').replace(/"/g, '""'));
  csvRows.push(row.map(v => `"${v}"`));
};

const saveCSV = () => {
  const csvContent = csvRows.map(r => r.join(',')).join('\n');
  fs.writeFileSync(OUTPUT_FILE, csvContent);
  log(`CSV saved: ${OUTPUT_FILE} (${csvRows.length - 1} records)`);
};

// ==================== DATA VALIDATION ====================
const validateEarnings = (fare: number, fee: number, tax: number, yourEarnings: number): boolean => {
  const calculated = fare - fee - tax;
  const diff = Math.abs(calculated - yourEarnings);
  return diff <= 1; // Allow 1 KSH rounding
};

// ==================== MAIN SCRAPER ====================
async function scrapeUberEarnings() {
  log('Starting Uber Earnings Scraper');
  initCSV();

  let context: BrowserContext | null = null;
  let page: Page | null = null;

  try {
    // Launch Brave with your profile
    context = await chromium.launchPersistentContext(BRAVE_PROFILE_PATH, {
      channel: 'brave',
      headless: false,
      viewport: { width: 1280, height: 800 },
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    page = context.pages()[0] || await context.newPage();
    await page.goto('https://drivers.uber.com/earnings/activities', { waitUntil: 'networkidle' });
    log('Navigated to earnings activities');

    let weekCount = 0;
    let totalRecords = 0;

    while (weekCount < MAX_WEEKS_BACK) {
      weekCount++;
      log(`Processing week ${weekCount}...`);

      try {
        // Load all activities
        let loadMoreAttempts = 0;
        while (await page.$('text=Load more') && loadMoreAttempts < 50) {
          await page.click('text=Load more');
          await page.waitForTimeout(1000);
          loadMoreAttempts++;
        }
        log(`Loaded all activities (attempts: ${loadMoreAttempts})`);

        // Get all rows
        const rows = await page.$$('table tbody tr');
        log(`Found ${rows.length} rows in week ${weekCount}`);

        if (rows.length === 0) {
          log('No rows found â†’ reached first trip. Stopping.');
          break;
        }

        // Process each row
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          try {
            const cells = await row.$$('td');
            if (cells.length < 4) continue;

            const event = await cells[0].textContent();
            const dateTimeRaw = await cells[1].textContent();
            const earningsRaw = await cells[2].textContent();
            const viewBtn = await cells[3].$('a, button');

            if (!viewBtn || !dateTimeRaw || !event || !earningsRaw) continue;

            const href = await viewBtn.getAttribute('href');
            if (!href) continue;

            // Parse Date & Time
            const cleaned = dateTimeRaw.replace('Boda ', '').trim();
            const [datePart, timePart] = cleaned.split(', ').map(s => s?.trim());
            if (!datePart || !timePart) continue;

            const earnings = parseFloat(earningsRaw.replace(/[^\d.-]/g, '')) || 0;

            // Open in new page
            const detailPage = await context!.newPage();
            let url = href.startsWith('http') ? href : `https://drivers.uber.com${href}`;
            await detailPage.goto(url, { waitUntil: 'networkidle' });
            await detailPage.waitForTimeout(DELAY_BETWEEN_DETAILS);

            let rowData: any = {
              Type: '',
              Date: datePart,
              Time: timePart,
              TripID: '',
              ActivityFeedUUID: '',
              Event: event,
              Earnings_KSH: earnings,
              Validation: 'OK'
            };

            if (href.includes('/trips/')) {
              // === TRIP ===
              rowData.Type = 'Trip';
              rowData.TripID = href.split('/').pop() || '';

              try {
                const duration = await detailPage.locator('text=Duration').locator('..').last().textContent();
                const distance = await detailPage.locator('text=Distance').locator('..').last().textContent();
                rowData.Duration = duration?.trim() || '';
                rowData.Distance_KM = distance?.trim() || '';

                const labels = ['Fare', 'Service fee', 'Taxes', 'Your earnings', 'Payouts', 'Trip balance'];
                for (const label of labels) {
                  const value = await detailPage.locator(`text=${label}`).locator('..').last().textContent();
                  const num = parseFloat(value?.replace(/[^\d.-]/g, '') || '0') || 0;
                  rowData[label.replace(/ /g, '')] = num;
                }

                // Validate
                const valid = validateEarnings(
                  rowData.Fare,
                  rowData.ServiceFee,
                  rowData.Taxes,
                  rowData.YourEarnings
                );
                rowData.Validation = valid ? 'OK' : 'MISMATCH';
                if (!valid) log(`Validation failed for Trip ${rowData.TripID}`, 'WARN');

                addRow(rowData);
                totalRecords++;
              } catch (err) {
                log(`Error parsing trip ${rowData.TripID}: ${err}`, 'ERROR');
              }

            } else if (href.includes('/activities/details')) {
              // === QUEST ===
              const isComplete = await detailPage.locator('text=Quest complete').count();
              if (!isComplete) {
                await detailPage.close();
                continue;
              }

              rowData.Type = 'Quest';
              const uuidMatch = href.match(/uuid=([^&]+)/);
              rowData.ActivityFeedUUID = uuidMatch ? uuidMatch[1] : '';

              try {
                const tripsText = await detailPage.locator('text=trips completed').first().textContent();
                const tripsDone = tripsText?.match(/\d+/)?.[0] || '';
                rowData.Quest_Trips_Completed = tripsDone;
                rowData.Quest_Bonus = earnings;

                addRow(rowData);
                totalRecords++;
              } catch (err) {
                log(`Error parsing quest: ${err}`, 'ERROR');
              }
            }

            await detailPage.close();
          } catch (err) {
            log(`Error processing row ${i}: ${err}`, 'ERROR');
          }
        }

        // === Go to Previous Week ===
        try {
          await page.click('[data-testid="date-range-picker"] button, button:has-text("week")');
          await page.click('text=Previous week');
          await page.click('text=Apply');
          await page.waitForLoadState('networkidle');
          log(`Moved to previous week`);
        } catch (err) {
          log(`Failed to go to previous week: ${err}`, 'ERROR');
          break;
        }

      } catch (weekErr) {
        log(`Week ${weekCount} failed: ${weekErr}`, 'ERROR');
        break;
      }
    }

    saveCSV();
    log(`Scraping complete. Total records: ${totalRecords}`);

  } catch (err) {
    log(`FATAL ERROR: ${err}`, 'ERROR');
  } finally {
    if (context) await context.close();
  }
}

// ==================== RUN ====================
scrapeUberEarnings().catch(err => log(`Unhandled error: ${err}`, 'ERROR'));